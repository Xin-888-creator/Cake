<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Photo Cake - Birthday Mode</title>
    <style>
        body { 
            margin: 0; overflow: hidden; 
            /* èƒŒæ™¯æ”¹ä¸ºæ›´åŠ æ¸©é¦¨çš„ç”Ÿæ—¥æ°›å›´æ¸å˜ */
            background: radial-gradient(circle at center, #1a0510 0%, #000000 100%);
            font-family: 'Arial', sans-serif; 
        }
         
        #top-header {
            position: absolute; top: 15px; left: 0; width: 100%;
            text-align: center; z-index: 50; pointer-events: none;
        }
        #top-header h1 {
            font-family: 'Brush Script MT', cursive; font-size: 55px; margin: 0;
            /* å­—ä½“é¢œè‰²æ”¹ä¸ºç²‰é‡‘æ¸å˜ */
            background: linear-gradient(to bottom, #fff, #ff69b4);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(255, 105, 180, 0.6));
            animation: floatText 4s ease-in-out infinite;
        }
        @keyframes floatText { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-8px);} }
 
        #ui-container {
            position: absolute; top: 120px; left: 20px; width: 260px;
            padding: 20px; 
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border-radius: 16px; border: 1px solid rgba(255, 182, 193, 0.3);
            color: #fff; z-index: 100; display: flex; flex-direction: column; gap: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }
 
        #video-wrapper {
            width: 100%; height: 160px; border-radius: 10px; overflow: hidden;
            background: #000; position: relative; transform: scaleX(-1);
            border: 1px solid rgba(255, 105, 180, 0.5);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
         
        .status-badge {
            position: absolute; top: 8px; right: 8px;
            background: #ff69b4; color: #fff;
            padding: 3px 8px; border-radius: 4px; font-size: 11px;
            transform: scaleX(-1); font-weight: 800; display: none;
        }
 
        .file-upload {
            background: rgba(255, 105, 180, 0.2);
            border: 1px solid rgba(255, 105, 180, 0.4);
            padding: 10px; border-radius: 8px; color: #ffb6c1; cursor: pointer;
            text-align: center; font-size: 13px; transition: 0.3s; font-weight: bold;
        }
        .file-upload:hover { background: rgba(255, 105, 180, 0.4); color: #fff; }
        input[type="file"] { display: none; }
 
        #gesture-info {
            font-size: 11px; color: #ffc0cb; line-height: 1.6;
            background: rgba(0,0,0,0.4); padding: 12px; border-radius: 8px;
        }
 
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            color: #ff69b4; z-index: 999; flex-direction: column;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
 
    <div id="top-header"><h1>Happy Birthday</h1></div>
 
    <div id="loader">
        <h2>ğŸ‚ ç”Ÿæ—¥è›‹ç³•ç³»ç»Ÿåˆå§‹åŒ–...</h2>
        <p>å¼€å¯æ‘„åƒå¤´ä»¥å¯ç”¨é­”æ³•</p>
    </div>
 
    <div id="ui-container">
        <div id="video-wrapper">
            <video id="input_video"></video>
            <div id="status-text" class="status-badge">Ready</div>
        </div>
        <label class="file-upload" for="photo-input">ğŸ“· ä¸Šä¼ ç…§ç‰‡è£…é¥°è›‹ç³• (å¤šé€‰)</label>
        <input type="file" id="photo-input" accept="image/*" multiple>
        <div id="gesture-info">
            âœ‹ <b>å¼ å¼€</b>ï¼šç…§ç‰‡çˆ†å‘ (å›å¿†æ˜Ÿç³»)<br>
            âœŠ <b>æ¡æ‹³</b>ï¼šç”Ÿæˆç”Ÿæ—¥è›‹ç³•<br>
            â˜ï¸ <b>å•æŒ‡</b>ï¼šå•å¼ ç‰¹å†™ (é™æ­¢æŸ¥çœ‹)<br>
            ğŸ‘Œ <b>OKæ‰‹</b>ï¼šç”Ÿæ—¥å¿«ä¹æ–‡å­—
        </div>
    </div>
 
    <script>
        // --- 1. åœºæ™¯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a0510, 0.002); // ç´«çº¢è‰²è¿·é›¾
 
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 85;
 
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
 
        // ç¯å…‰ - æ›´åŠ æ¸©æš–
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const mainLight = new THREE.PointLight(0xffaa33, 2, 150); // çƒ›å…‰è‰²
        mainLight.position.set(20, 50, 40);
        scene.add(mainLight);
        const fillLight = new THREE.PointLight(0xff69b4, 1.5, 100); // ç²‰è‰²è¡¥å…‰
        fillLight.position.set(-30, 10, 30);
        scene.add(fillLight);
 
        // --- 2. æ°›å›´ç²’å­ (æŠŠé›ªèŠ±æ”¹æˆå½©çº¸ Confetti) ---
        function createConfettiTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            context.fillStyle = '#fff';
            context.fillRect(0,0,32,32); // æ–¹å—å½©çº¸
            return new THREE.CanvasTexture(canvas);
        }
        const confettiCount = 600;
        const confettiGeo = new THREE.BufferGeometry();
        const confettiPos = new Float32Array(confettiCount * 3);
        const confettiColors = new Float32Array(confettiCount * 3);
        const colorPalette = [new THREE.Color(0xff0000), new THREE.Color(0x00ff00), new THREE.Color(0x0000ff), new THREE.Color(0xffff00)];
        
        for(let i=0;i<confettiCount;i++) {
            confettiPos[i*3] = (Math.random()-0.5)*200;
            confettiPos[i*3+1] = (Math.random()-0.5)*200;
            confettiPos[i*3+2] = (Math.random()-0.5)*200;
            
            const c = colorPalette[Math.floor(Math.random()*4)];
            confettiColors[i*3] = c.r; confettiColors[i*3+1] = c.g; confettiColors[i*3+2] = c.b;
        }
        confettiGeo.setAttribute('position', new THREE.BufferAttribute(confettiPos, 3));
        confettiGeo.setAttribute('color', new THREE.BufferAttribute(confettiColors, 3));
        const confettiMat = new THREE.PointsMaterial({
            size: 1.5, vertexColors: true, map: createConfettiTexture(), transparent: true, opacity: 0.8
        });
        const confettiSystem = new THREE.Points(confettiGeo, confettiMat);
        scene.add(confettiSystem);
 
        // --- 3. ç²’å­ç³»ç»Ÿ (æ„æˆè›‹ç³•çš„ä¸»ä½“) ---
        const totalParticles = 2800;
        const countCubes = 1500; const countSpheres = 1000; const countFrames = 300;
 
        const cubeGeo = new THREE.BoxGeometry(0.7, 0.7, 0.7); // åƒç³–ç 
        const sphereGeo = new THREE.SphereGeometry(0.5, 12, 12); // åƒå¥¶æ²¹çƒ
        const frameGeo = new THREE.TorusGeometry(1.0, 0.1, 4, 8); // è£…é¥°åœˆ
 
        // æè´¨æ”¹ä¸ºè›‹ç³•è‰²ç³»ï¼šå¥¶æ²¹ç™½ã€ç²‰è‰²ã€é‡‘è‰²
        const matCream = new THREE.MeshStandardMaterial({ color: 0xfffff0, roughness: 0.3 });
        const matPink = new THREE.MeshStandardMaterial({ color: 0xff69b4, roughness: 0.2 });
        const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.6, roughness: 0.2 });
 
        const meshCubes = new THREE.InstancedMesh(cubeGeo, matPink, countCubes);
        const meshSpheres = new THREE.InstancedMesh(sphereGeo, matCream, countSpheres);
        const meshFrames = new THREE.InstancedMesh(frameGeo, matGold, countFrames);
 
        scene.add(meshCubes); scene.add(meshSpheres); scene.add(meshFrames);
 
        const targetPositions = new Float32Array(totalParticles * 3);
        const currentPositions = new Float32Array(totalParticles * 3);
        const dummy = new THREE.Object3D();
        
        // éšæœºåˆå§‹åŒ–ä½ç½®
        for(let i=0; i<totalParticles; i++) {
            currentPositions[i*3] = (Math.random()-0.5)*150;
            currentPositions[i*3+1] = (Math.random()-0.5)*150;
            currentPositions[i*3+2] = (Math.random()-0.5)*150;
        }
 
        // --- 4. é¡¶éƒ¨çƒ›ç« (ä»£æ›¿æ˜Ÿæ˜Ÿ) ---
        const flameGeo = new THREE.OctahedronGeometry(2, 0);
        const flameMat = new THREE.MeshStandardMaterial({ 
            color: 0xff4500, emissive: 0xff0000, emissiveIntensity: 2, transparent: true, opacity: 0.9 
        });
        const topFlame = new THREE.Mesh(flameGeo, flameMat);
        
        // çƒ›èŠ¯
        const wickGeo = new THREE.CylinderGeometry(0.1, 0.1, 2);
        const wickMat = new THREE.MeshBasicMaterial({color: 0x000000});
        const wick = new THREE.Mesh(wickGeo, wickMat);
        wick.position.y = -1.5;
        topFlame.add(wick);
        
        scene.add(topFlame);
 
        // --- 5. å·¨å‹è‰ºæœ¯å­— & ç…§ç‰‡ ---
        const textPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(45, 18), 
            new THREE.MeshBasicMaterial({side:THREE.DoubleSide, transparent:true})
        );
        textPlane.renderOrder = 999; 
         
        function makeArtTextTex() {
            const c=document.createElement('canvas'); c.width=4096; c.height=1024;
            const x=c.getContext('2d');
            x.shadowColor="#ff1493"; x.shadowBlur=40; // ç²‰è‰²å…‰æ™•
            x.fillStyle="#fff"; 
            x.font="bold 400px 'Brush Script MT', cursive"; 
            x.textAlign="center"; x.textBaseline="middle";
            x.fillText("Happy Birthday!", 2048, 512);
            return new THREE.CanvasTexture(c);
        }
        textPlane.material.map = makeArtTextTex();
        textPlane.visible = false;
        scene.add(textPlane);
 
        // --- 6. ç…§ç‰‡é€»è¾‘ ---
        const photoGroup = new THREE.Group();
        const photoPlane = new THREE.Mesh(new THREE.PlaneGeometry(36, 27), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
        const photoBorder = new THREE.Mesh(new THREE.PlaneGeometry(37, 28), new THREE.MeshBasicMaterial({color:0xff69b4})); // ç²‰æ¡†
        photoBorder.position.z = -0.1;
        photoGroup.add(photoPlane); photoGroup.add(photoBorder);
        photoGroup.visible = false;
        photoGroup.renderOrder = 999; 
        scene.add(photoGroup);
 
        const galleryGroup = new THREE.Group();
        scene.add(galleryGroup);
 
        let mode = 'cake'; // é»˜è®¤ä¸ºè›‹ç³•æ¨¡å¼
        let photoImages = [];
        let handRot = {x:0, y:0};
        let animState = { photo: 0, text: 0, galaxy: 0 };
 
        // åˆ›å»ºç…§ç‰‡äº‘
        function createGalleryCloud() {
            while(galleryGroup.children.length > 0) galleryGroup.remove(galleryGroup.children[0]);
            if(photoImages.length === 0) return;
 
            const totalGalleryCount = 40;
            const geo = new THREE.PlaneGeometry(8, 6);
            const borderGeo = new THREE.PlaneGeometry(8.5, 6.5);
            const borderMat = new THREE.MeshBasicMaterial({color: 0xffd700}); // é‡‘æ¡†
 
            for(let i=0; i<totalGalleryCount; i++) {
                const imgTex = photoImages[i % photoImages.length];
                const mat = new THREE.MeshBasicMaterial({map: imgTex, side: THREE.DoubleSide});
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.05;
                mesh.add(border);
 
                // ç¯ç»•å¼åˆ†å¸ƒ
                const r = 30 + Math.random() * 20;
                const theta = Math.random() * Math.PI * 2;
                const y = (Math.random() - 0.5) * 40;
 
                mesh.userData = {
                    targetPos: new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta)),
                    rotSpeed: (Math.random()-0.5) * 0.02
                };
                mesh.position.set(0,0,0);
                mesh.scale.set(0,0,0);
                galleryGroup.add(mesh);
            }
        }
 
        // --- æ ¸å¿ƒå½¢çŠ¶ç®—æ³• ---
        function calculateTargets(type) {
            const scale = 1.0;
 
            if (type === 'nebula') { // çˆ†å‘æ¨¡å¼
                for(let i=0; i<totalParticles; i++){
                    const r=90*Math.cbrt(Math.random()); 
                    const th=Math.random()*2*Math.PI; 
                    const ph=Math.acos(2*Math.random()-1);
                    targetPositions[i*3] = r*Math.sin(ph)*Math.cos(th);
                    targetPositions[i*3+1] = r*Math.sin(ph)*Math.sin(th);
                    targetPositions[i*3+2] = r*Math.cos(ph);
                }
            }
            else if (type === 'cake') { // ã€æ ¸å¿ƒä¿®æ”¹ã€‘è›‹ç³•å½¢çŠ¶
                for(let i=0; i<totalParticles; i++){
                    const p = Math.random(); // å†³å®šç²’å­åœ¨å“ªä¸ªéƒ¨åˆ†
                    let y, r, rMax;
                    
                    // åˆ†å±‚é€»è¾‘
                    if (p < 0.45) {
                        // åº•å±‚ (æœ€å¤§)
                        y = -15 + Math.random() * 10; // é«˜åº¦ -15 åˆ° -5
                        rMax = 22;
                    } else if (p < 0.75) {
                        // ä¸­å±‚
                        y = -5 + Math.random() * 10; // é«˜åº¦ -5 åˆ° 5
                        rMax = 15;
                    } else if (p < 0.95) {
                        // é¡¶å±‚
                        y = 5 + Math.random() * 8; // é«˜åº¦ 5 åˆ° 13
                        rMax = 9;
                    } else {
                        // é¡¶éƒ¨èœ¡çƒ›ç«ç„°å‘¨å›´çš„å…‰æ™•
                        y = 13 + Math.random() * 6;
                        rMax = 2; // ç»†é•¿çš„ä¸­å¿ƒ
                    }
 
                    // è®©ç²’å­å¡«å……å†…éƒ¨ï¼Œè€Œä¸ä»…ä»…æ˜¯è¡¨é¢
                    r = rMax * Math.sqrt(Math.random()); 
                    const theta = Math.random() * 2 * Math.PI;
 
                    targetPositions[i*3] = r * Math.cos(theta);
                    targetPositions[i*3+1] = y * scale;
                    targetPositions[i*3+2] = r * Math.sin(theta);
                }
            }
            else if (type === 'avoid') { // é¿è®©æ¨¡å¼ (ç»™æ–‡å­—/å•å¼ ç…§ç‰‡ç•™ä½ç½®)
                for(let i=0; i<totalParticles; i++){
                    const r=50+Math.random()*40; 
                    const ang=Math.random()*2*Math.PI;
                    let x=r*Math.cos(ang); 
                    let y=r*Math.sin(ang)*0.6; 
                    let z=(Math.random()-0.5)*50; 
                    if (Math.abs(x) < 25 && Math.abs(y) < 20) z = -60 - Math.random()*30;
                    targetPositions[i*3] = x;
                    targetPositions[i*3+1] = y;
                    targetPositions[i*3+2] = z;
                }
            }
        }
        calculateTargets('cake'); // é»˜è®¤è›‹ç³•
 
        document.getElementById('photo-input').addEventListener('change', (e) => {
            const f = e.target.files;
            if(f.length){
                photoImages = [];
                let loadCount = 0;
                const limit = Math.min(f.length, 30);
                for(let i=0; i<limit; i++){
                    const r = new FileReader();
                    r.onload = (ev) => {
                        const img = new Image(); img.src=ev.target.result;
                        img.onload=()=>{
                            const t=new THREE.CanvasTexture(img); 
                            t.colorSpace=THREE.SRGBColorSpace;
                            photoImages.push(t);
                            loadCount++;
                            if(loadCount === limit) createGalleryCloud();
                        }
                    };
                    r.readAsDataURL(f[i]);
                }
            }
        });
 
        // --- 7. åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();
        const dummyV = new THREE.Vector3();
 
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
 
            // åŸºç¡€æ—‹è½¬
            let tx = 0, ty = 0;
            if (mode !== 'photo') {
                tx = handRot.y * 0.4; // ç¨å¾®å‡å¼±æ‰‹åŠ¿æ—‹è½¬å¹…åº¦ï¼Œä¿æŒè›‹ç³•ç¨³å®š
                ty = handRot.x * 0.6;
            }
            const rotSpeed = 0.08;
            meshCubes.rotation.x = THREE.MathUtils.lerp(meshCubes.rotation.x, tx, rotSpeed);
            meshCubes.rotation.y = THREE.MathUtils.lerp(meshCubes.rotation.y, ty + time * 0.1, rotSpeed); // è‡ªåŠ¨æ…¢é€Ÿæ—‹è½¬
            meshSpheres.rotation.copy(meshCubes.rotation); 
            meshFrames.rotation.copy(meshCubes.rotation);
 
            galleryGroup.rotation.y += 0.003;
            galleryGroup.rotation.x = meshCubes.rotation.x * 0.5;
 
            // 1. è›‹ç³•æ¨¡å¼é€»è¾‘
            if (mode === 'cake') {
                topFlame.visible = true;
                // çƒ›ç«è·³åŠ¨æ•ˆæœ
                const flicker = 1 + Math.sin(time * 20) * 0.1 + Math.cos(time * 45) * 0.1;
                topFlame.scale.set(flicker, flicker*1.2, flicker);
                // ä½ç½®å¯¹é½åˆ°è›‹ç³•é¡¶éƒ¨ä¸­å¿ƒ
                topFlame.position.set(0, 15, 0); 
                topFlame.position.applyEuler(meshCubes.rotation);
            } else {
                topFlame.visible = false;
            }
 
            // 2. å•å¼ ç‰¹å†™
            if (mode === 'photo') {
                photoGroup.visible = true;
                animState.photo = THREE.MathUtils.lerp(animState.photo, 1, 0.15); 
                const s = animState.photo;
                const z = -20 * (1-s) + 12; 
                photoGroup.scale.set(s, s, s);
                photoGroup.position.set(0, 0, z); 
                photoGroup.rotation.z = (1-s) * 0.2;
            } else {
                photoGroup.visible = false;
                animState.photo = 0;
            }
 
            // 3. æ–‡å­—
            if (mode === 'text') {
                textPlane.visible = true;
                animState.text = THREE.MathUtils.lerp(animState.text, 1, 0.1);
                const s = 1 + Math.sin((1-animState.text)*Math.PI)*0.3; 
                textPlane.scale.set(s,s,1);
                textPlane.position.set(0, Math.sin(time*2)*0.5, 18); 
            } else {
                textPlane.visible = false;
                animState.text = 0;
            }
 
            // 4. æ˜Ÿäº‘/ç…§ç‰‡äº‘
            if (mode === 'nebula') {
                animState.galaxy = THREE.MathUtils.lerp(animState.galaxy, 1, 0.05);
                galleryGroup.children.forEach(mesh => {
                    mesh.position.lerp(mesh.userData.targetPos, 0.05);
                    mesh.scale.setScalar(animState.galaxy);
                    mesh.lookAt(camera.position);
                    mesh.position.y += Math.sin(time + mesh.id) * 0.02;
                });
            } else {
                animState.galaxy = THREE.MathUtils.lerp(animState.galaxy, 0, 0.1);
                galleryGroup.children.forEach(mesh => {
                    mesh.position.lerp(new THREE.Vector3(0,0,0), 0.1);
                    mesh.scale.setScalar(animState.galaxy);
                });
            }
 
            // ç²’å­æ’å€¼
            const particleLerp = (mode === 'photo') ? 0.9 : 0.08;
            for(let i=0; i<totalParticles; i++){
                const ix=i*3, iy=i*3+1, iz=i*3+2;
                currentPositions[ix] += (targetPositions[ix]-currentPositions[ix])*particleLerp;
                currentPositions[iy] += (targetPositions[iy]-currentPositions[iy])*particleLerp;
                currentPositions[iz] += (targetPositions[iz]-currentPositions[iz])*particleLerp;
                
                dummyV.set(currentPositions[ix], currentPositions[iy], currentPositions[iz]);
                dummy.position.copy(dummyV);
                
                // ç²’å­è‡ªè½¬
                let s = 1.0;
                if (mode !== 'photo') {
                   dummy.rotation.set(time+i, time*0.5+i, 0);
                   s = (i < countCubes) ? 1.0 : 0.6; // ç³–çƒå°ä¸€ç‚¹
                } else {
                   dummy.rotation.set(0,0,0);
                }
                
                dummy.scale.set(s,s,s);
                dummy.updateMatrix();
 
                if(i<countCubes) meshCubes.setMatrixAt(i, dummy.matrix);
                else if(i<countCubes+countSpheres) meshSpheres.setMatrixAt(i-countCubes, dummy.matrix);
                else meshFrames.setMatrixAt(i-countCubes-countSpheres, dummy.matrix);
            }
            meshCubes.instanceMatrix.needsUpdate=true;
            meshSpheres.instanceMatrix.needsUpdate=true;
            meshFrames.instanceMatrix.needsUpdate=true;
 
            // å½©çº¸é£˜è½
            const cp = confettiSystem.geometry.attributes.position.array;
            for(let i=0; i<confettiCount; i++){
                cp[i*3+1] -= 0.2; 
                cp[i*3] += Math.sin(time + i)*0.1; // å·¦å³é£˜
                if(cp[i*3+1]<-100) cp[i*3+1]=100;
            }
            confettiSystem.geometry.attributes.position.needsUpdate=true;
            confettiSystem.rotation.y = time * 0.05;
 
            renderer.render(scene, camera);
        }
        animate();
 
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
 
        // --- 8. æ‰‹åŠ¿ ---
        const videoElement = document.getElementById('input_video');
        const statusText = document.getElementById('status-text');
 
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            statusText.style.display = 'block';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const cx = (lm[0].x+lm[9].x)/2; const cy = (lm[0].y+lm[9].y)/2;
                handRot.x = (cx-0.5)*3; handRot.y = (cy-0.5)*3;
                handleGesture(detect(lm));
            }
        }
        function detect(lm) {
            const d = (i1, i2) => Math.hypot(lm[i1].x-lm[i2].x, lm[i1].y-lm[i2].y);
            const o = (t, p) => d(t, 0) > d(p, 0);
            const i=o(8,6), m=o(12,10), r=o(16,14), p=o(20,18);
            if(!i&&!m&&!r&&!p) return 'FIST'; // æ¡æ‹³ -> è›‹ç³•
            if(i && !m && !r && !p) return 'POINTING'; // å•æŒ‡ -> å•å¼ 
            if(d(4,8)<0.05&&m&&r&&p) return 'OK'; // OK -> æ–‡å­—
            if(i&&m&&r&&p) return 'OPEN'; // å¼ å¼€ -> çˆ†å‘
            return 'UNKNOWN';
        }
        let lastG = '';
        function handleGesture(g) {
            if(g===lastG) return;
            lastG = g; statusText.innerText = g;
            switch(g){
                case 'OPEN': 
                    mode='nebula'; 
                    calculateTargets('nebula'); 
                    if(galleryGroup.children.length === 0 && photoImages.length > 0) createGalleryCloud();
                    break;
                case 'FIST': 
                    mode='cake'; 
                    calculateTargets('cake'); 
                    break;
                case 'POINTING': 
                    mode='photo'; 
                    calculateTargets('avoid'); 
                    if(photoImages.length) {
                        photoPlane.material.map=photoImages[Math.floor(Math.random()*photoImages.length)];
                        photoPlane.material.needsUpdate=true;
                    } else {
                        // æ²¡ç…§ç‰‡æ—¶çš„æç¤º
                        const c=document.createElement('canvas');c.width=400;c.height=300;
                        const x=c.getContext('2d');x.fillStyle='#000';x.fillRect(0,0,400,300);
                        x.fillStyle='#ff69b4';x.font='30px Arial';x.textAlign='center';x.textBaseline='middle';
                        x.fillText("Please Upload Photos",200,150);
                        photoPlane.material.map=new THREE.CanvasTexture(c);
                    }
                    break;
                case 'OK': mode='text'; calculateTargets('avoid'); break;
            }
        }
 
        const hands = new Hands({locateFile: f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
        hands.onResults(onResults);
        const cam = new Camera(videoElement, {onFrame: async()=>{await hands.send({image:videoElement})}, width:320, height:240});
        cam.start();
    </script>
</body>
</html>
