<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>True Cake Photo Display</title>
    <style>
        body { 
            margin: 0; overflow: hidden; 
            /* èƒŒæ™¯æ›´æš–ï¼Œæ›´æœ‰èŠ‚æ—¥æ°”æ°› */
            background: radial-gradient(circle at center, #2a0a15 0%, #050205 100%);
            font-family: 'Arial', sans-serif; 
        }
         
        #top-header {
            position: absolute; top: 15px; left: 0; width: 100%;
            text-align: center; z-index: 50; pointer-events: none;
        }
        #top-header h1 {
            font-family: 'Brush Script MT', cursive; font-size: 55px; margin: 0;
            background: linear-gradient(to bottom, #fff, #ff99cc);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(255, 153, 204, 0.7));
            animation: floatText 4s ease-in-out infinite;
        }
        @keyframes floatText { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-8px);} }
 
        #ui-container {
            position: absolute; top: 120px; left: 20px; width: 260px;
            padding: 20px; 
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border-radius: 16px; border: 1px solid rgba(255, 192, 203, 0.4);
            color: #fff; z-index: 100; display: flex; flex-direction: column; gap: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }
 
        #video-wrapper {
            width: 100%; height: 160px; border-radius: 10px; overflow: hidden;
            background: #000; position: relative; transform: scaleX(-1);
            border: 2px solid rgba(255, 105, 180, 0.6);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
         
        .status-badge {
            position: absolute; top: 8px; right: 8px;
            background: #ff1493; color: #fff;
            padding: 3px 8px; border-radius: 4px; font-size: 11px;
            transform: scaleX(-1); font-weight: 800; display: none;
        }
 
        .file-upload {
            background: linear-gradient(45deg, #ff69b4, #ffb6c1);
            border: none;
            padding: 12px; border-radius: 8px; color: #fff; cursor: pointer;
            text-align: center; font-size: 13px; transition: 0.3s; font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 105, 180, 0.4);
        }
        .file-upload:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 105, 180, 0.6); }
        input[type="file"] { display: none; }
 
        #gesture-info {
            font-size: 11px; color: #ffcce0; line-height: 1.7;
            background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #gesture-info b { color: #fff; }
 
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #050205; display: flex; justify-content: center; align-items: center;
            color: #ff69b4; z-index: 999; flex-direction: column;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
 
    <div id="top-header"><h1>Happy Birthday</h1></div>
 
    <div id="loader">
        <h2>ğŸ‚ æ­£åœ¨çƒ˜ç„™ç²’å­è›‹ç³•...</h2>
        <p>è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¯ç”¨æ‰‹åŠ¿æ§åˆ¶</p>
    </div>
 
    <div id="ui-container">
        <div id="video-wrapper">
            <video id="input_video"></video>
            <div id="status-text" class="status-badge">Ready</div>
        </div>
        <label class="file-upload" for="photo-input">ğŸ“· ä¸Šä¼ ç…§ç‰‡ (å»ºè®®å¤šå¼ )</label>
        <input type="file" id="photo-input" accept="image/*" multiple>
        <div id="gesture-info">
            âœ‹ <b>å¼ å¼€æ‰‹æŒ</b>ï¼šç…§ç‰‡æ˜Ÿç³»çˆ†å‘<br>
            âœŠ <b>æ¡ç´§æ‹³å¤´</b>ï¼šé‡ç»„ç”Ÿæ—¥è›‹ç³•<br>
            â˜ï¸ <b>ä¼¸å‡ºé£ŸæŒ‡</b>ï¼šæŸ¥çœ‹å•å¼ ç…§ç‰‡<br>
            ğŸ‘Œ <b>OKæ‰‹åŠ¿</b>ï¼šæ˜¾ç¤ºç”Ÿæ—¥ç¥ç¦
        </div>
    </div>
 
    <script>
        // --- 1. åœºæ™¯è®¾ç½® ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x2a0a15, 0.0025); 
 
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 90); // ç¨å¾®æŠ¬é«˜ç›¸æœºè§†è§’
        camera.lookAt(0,0,0);
 
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);
 
        // ç¯å…‰ç³»ç»Ÿ - æ›´åŠ å¼ºè°ƒç«‹ä½“æ„Ÿ
        const ambientLight = new THREE.AmbientLight(0xffddee, 0.4);
        scene.add(ambientLight);
        
        // ä¸»å…‰æº - æš–é‡‘è‰²
        const mainLight = new THREE.PointLight(0xffd700, 1.5, 200);
        mainLight.position.set(50, 80, 50);
        scene.add(mainLight);
        
        // ä¾§é¢è¡¥å…‰ - ç²‰ç´«è‰²ï¼Œå‹¾å‹’è¾¹ç¼˜
        const rimLight = new THREE.PointLight(0xff1493, 2, 150);
        rimLight.position.set(-50, 20, -30);
        scene.add(rimLight);
 
        // --- 2. æ°›å›´å½©çº¸ ---
        function createConfettiTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = '#fff';
            context.beginPath();
            context.moveTo(32,0); context.lineTo(64,32); context.lineTo(32,64); context.lineTo(0,32); context.closePath();
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }
        const confettiCount = 500;
        const confettiGeo = new THREE.BufferGeometry();
        const confettiPos = new Float32Array(confettiCount * 3);
        const confettiColors = new Float32Array(confettiCount * 3);
        const colorPalette = [new THREE.Color(0xff69b4), new THREE.Color(0xffd700), new THREE.Color(0xffffff), new THREE.Color(0x87ceeb)];
        
        for(let i=0;i<confettiCount;i++) {
            confettiPos[i*3] = (Math.random()-0.5)*250;
            confettiPos[i*3+1] = Math.random()*200 - 50;
            confettiPos[i*3+2] = (Math.random()-0.5)*250;
            const c = colorPalette[Math.floor(Math.random()*colorPalette.length)];
            confettiColors[i*3] = c.r; confettiColors[i*3+1] = c.g; confettiColors[i*3+2] = c.b;
        }
        confettiGeo.setAttribute('position', new THREE.BufferAttribute(confettiPos, 3));
        confettiGeo.setAttribute('color', new THREE.BufferAttribute(confettiColors, 3));
        const confettiMat = new THREE.PointsMaterial({
            size: 2, vertexColors: true, map: createConfettiTexture(), transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending
        });
        const confettiSystem = new THREE.Points(confettiGeo, confettiMat);
        scene.add(confettiSystem);
 
        // --- 3. å®ä½“ç²’å­ç³»ç»Ÿ (å…³é”®ä¿®æ”¹ï¼šå¢åŠ ç²’å­æ•°é‡ï¼Œè°ƒæ•´æ¯”ä¾‹) ---
        const totalParticles = 3500; // å¢åŠ ç²’å­ä»¥è·å¾—æ›´å¯†å®çš„å¯¹é½
        // è°ƒæ•´æ¯”ä¾‹ï¼šæ›´å¤šç«‹æ–¹ä½“åšè›‹ç³•ä½“ï¼Œæ›´å¤šçƒä½“åšå¥¶æ²¹è£…é¥°
        const countCubes = 2000; 
        const countSpheres = 1200; 
        const countFrames = 300;
 
        const cubeGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8); 
        const sphereGeo = new THREE.SphereGeometry(0.6, 16, 16); 
        const frameGeo = new THREE.TorusGeometry(1.0, 0.15, 8, 16); // ç¯å½¢æ›´åœ†æ»‘
 
        // æè´¨ - å¼ºè°ƒå…‰æ³½æ„Ÿ
        const matPink = new THREE.MeshStandardMaterial({ color: 0xff69b4, roughness: 0.4, metalness: 0.1 });
        const matCream = new THREE.MeshStandardMaterial({
    color: 0xfffff5,
    roughness: 0.15,
    metalness: 0.05,
    emissive: 0xffe4ec,
    emissiveIntensity: 0.25
});
        const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.1 });
 
        const meshCubes = new THREE.InstancedMesh(cubeGeo, matPink, countCubes);
        const meshSpheres = new THREE.InstancedMesh(sphereGeo, matCream, countSpheres);
        meshFrames.position.y = Math.sin(time * 0.8) * 0.3;
meshFrames.scale.set(1.2, 1, 1.2);
 
        scene.add(meshCubes); scene.add(meshSpheres); scene.add(meshFrames);
 
        const targetPositions = new Float32Array(totalParticles * 3);
        const currentPositions = new Float32Array(totalParticles * 3);
        const dummy = new THREE.Object3D();
        
        for(let i=0; i<totalParticles; i++) {
            currentPositions[i*3] = (Math.random()-0.5)*200;
            currentPositions[i*3+1] = (Math.random()-0.5)*200;
            currentPositions[i*3+2] = (Math.random()-0.5)*200;
        }
 
        // --- 4. é¡¶éƒ¨ä¸»çƒ›ç« ---
        const flameGroup = new THREE.Group();
        const flameGeo = new THREE.SphereGeometry(2, 32, 32);
        const flameMat = new THREE.MeshStandardMaterial({ 
            color: 0xff4500, emissive: 0xff2200, emissiveIntensity: 5, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending
        });
        const topFlame = new THREE.Mesh(flameGeo, flameMat);
        // å…‰æ™•
        const glowGeo = new THREE.PlaneGeometry(12, 12);
        const glowTex = createSnowflakeTexture(); // å¤ç”¨ä¹‹å‰çš„å¾„å‘æ¸å˜è´´å›¾
        const glowMat = new THREE.MeshBasicMaterial({
            map: glowTex, color: 0xff4500, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const glowMesh = new THREE.Mesh(glowGeo, glowMat);
        flameGroup.add(topFlame);
        flameGroup.add(glowMesh);
        scene.add(flameGroup);
 
        function createSnowflakeTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            context.fillStyle = gradient;
            context.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(canvas);
        }
        const flameGlow = new THREE.Mesh(
    new THREE.SphereGeometry(3.2, 16, 16),
    new THREE.MeshBasicMaterial({
        color: 0xffaa55,
        transparent: true,
        opacity: 0.25
    })
);
topFlame.add(flameGlow);
 
        // --- 5. æ–‡å­— & ç…§ç‰‡å¹³é¢ ---
        const textPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(50, 20), 
            new THREE.MeshBasicMaterial({side:THREE.DoubleSide, transparent:true, opacity: 0})
        );
        textPlane.renderOrder = 999; 
         
        function makeArtTextTex() {
            const c=document.createElement('canvas'); c.width=2048; c.height=1024;
            const x=c.getContext('2d');
            x.fillStyle = "rgba(0,0,0,0)"; x.fillRect(0,0,c.width,c.height);
            x.shadowColor="#ff1493"; x.shadowBlur=30;
            x.shadowOffsetX=5; x.shadowOffsetY=5;
            x.fillStyle="#ffffff"; 
            x.font="bold 350px 'Brush Script MT', cursive"; 
            x.textAlign="center"; x.textBaseline="middle";
            x.fillText("Happy Birthday!", 1024, 512);
            // åŠ ç‚¹è£…é¥°çº¿
            x.shadowBlur=0; x.shadowOffset=0;
            x.strokeStyle = "#ffd700"; x.lineWidth = 10;
            x.beginPath(); x.moveTo(500, 700); x.quadraticCurveTo(1024, 800, 1548, 700); x.stroke();
            return new THREE.CanvasTexture(c);
        }
        textPlane.material.map = makeArtTextTex();
        scene.add(textPlane);
 
        const photoGroup = new THREE.Group();
        const photoPlane = new THREE.Mesh(new THREE.PlaneGeometry(40, 30), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
        const photoBorder = new THREE.Mesh(new THREE.PlaneGeometry(42, 32), new THREE.MeshStandardMaterial({color:0xffd700, metalness:0.8, roughness:0.2}));
        photoBorder.position.z = -0.2;
        photoGroup.add(photoPlane); photoGroup.add(photoBorder);
        photoGroup.visible = false; photoGroup.renderOrder = 999; 
        scene.add(photoGroup);
 
        const galleryGroup = new THREE.Group();
        scene.add(galleryGroup);
 
        let mode = 'cake';
        let photoImages = [];
        let handRot = {x:0, y:0};
        let animState = { photo: 0, text: 0, galaxy: 0 };
 
        function createGalleryCloud() {
            while(galleryGroup.children.length > 0) galleryGroup.remove(galleryGroup.children[0]);
            if(photoImages.length === 0) return;
            const totalGalleryCount = 50;
            const geo = new THREE.PlaneGeometry(8, 6);
            const borderMat = new THREE.MeshBasicMaterial({color: 0xffd700});
            for(let i=0; i<totalGalleryCount; i++) {
                const imgTex = photoImages[i % photoImages.length];
                const mat = new THREE.MeshBasicMaterial({map: imgTex, side: THREE.DoubleSide});
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(new THREE.PlaneGeometry(8.5, 6.5), borderMat); border.position.z = -0.05; mesh.add(border);
                // èºæ—‹ä¸Šå‡åˆ†å¸ƒ
                const r = 20 + i * 0.5;
                const theta = i * 0.4;
                const y = i * 1.5 - 30;
                mesh.userData = { targetPos: new THREE.Vector3(r*Math.cos(theta), y, r*Math.sin(theta)) };
                mesh.position.set(0,0,0); mesh.scale.set(0,0,0);
                galleryGroup.add(mesh);
            }
        }
 
        // --- 6. æ ¸å¿ƒé€ å‹ç®—æ³• (é‡ä¸­ä¹‹é‡ï¼šå¦‚ä½•è®©ç²’å­åƒè›‹ç³•) ---
        function calculateTargets(type) {
            // é‡ç½®
            for(let i=0; i<totalParticles*3; i++) targetPositions[i] = currentPositions[i];

            if (type === 'nebula') { // çˆ†å‘æ¨¡å¼
                for(let i=0; i<totalParticles; i++){
                    const r=120*Math.cbrt(Math.random()); 
                    const th=Math.random()*2*Math.PI; 
                    const ph=Math.acos(2*Math.random()-1);
                    targetPositions[i*3] = r*Math.sin(ph)*Math.cos(th);
                    targetPositions[i*3+1] = r*Math.sin(ph)*Math.sin(th);
                    targetPositions[i*3+2] = r*Math.cos(ph);
                }
            }
            // ã€æ ¸å¿ƒä¿®æ”¹ã€‘å®ä½“è›‹ç³•é€ å‹
           else if (type === 'cake') {
    for(let i=0; i<totalParticles; i++){
        const p = Math.random();
        let y, r, rMax;

        if (p < 0.42) {
            // ğŸ° åº•å±‚ï¼ˆæœ€å¤§ã€ç¨³ï¼‰
            y = -18 + Math.random() * 10;   // -18 ~ -8
            rMax = 24;
        } 
        else if (p < 0.70) {
            // ğŸ° ä¸­å±‚
            y = -6 + Math.random() * 8;     // -6 ~ 2
            rMax = 16;
        } 
        else if (p < 0.90) {
            // ğŸ° é¡¶å±‚
            y = 4 + Math.random() * 7;      // 4 ~ 11
            rMax = 9;
        } 
        else {
            // ğŸ•¯ èœ¡çƒ›å…‰æ™•
            y = 12 + Math.random() * 5;
            rMax = 2.2;
        }

        // è¡¨é¢æ›´å¯†ï¼Œå†…éƒ¨ç¨å¾®ç©ºä¸€ç‚¹ â†’ æ›´åƒè›‹ç³•
        r = rMax * Math.pow(Math.random(), 0.6);
        const theta = Math.random() * Math.PI * 2;

        targetPositions[i*3]     = r * Math.cos(theta);
        targetPositions[i*3 + 1] = y;
        targetPositions[i*3 + 2] = r * Math.sin(theta);
    }

                // å®šä¹‰è›‹ç³•å±‚å‚æ•° [åŠå¾„, åº•éƒ¨é«˜åº¦, é¡¶éƒ¨é«˜åº¦]
                const tiers = [
                    [28, -20, -8], // åº•å±‚
                    [20, -8, 4],   // ä¸­å±‚
                    [12, 4, 14]    // é¡¶å±‚
                ];

                // --- 1. æ„å»ºè›‹ç³•ä½“ (ä½¿ç”¨å¤§éƒ¨åˆ†ç«‹æ–¹ä½“å’Œä¸€äº›ç¯) ---
                // ç­–ç•¥ï¼šè®©ç²’å­ç´§è´´åœ†æŸ±ä½“ä¾§é¢è¡¨é¢ï¼Œè€Œä¸æ˜¯å¡«å……å†…éƒ¨
                tiers.forEach((tier, tierIndex) => {
                    const [radius, bottomY, topY] = tier;
                    const particlesForThisTier = 700 - tierIndex * 150; // åº•å±‚ç²’å­å¤šï¼Œé¡¶å±‚å°‘

                    for(let i=0; i<particlesForThisTier; i++) {
                        if(idx >= totalParticles) break;
                        const theta = (i / particlesForThisTier) * Math.PI * 2 * (3 + tierIndex); // å¤šç»•å‡ åœˆç¡®ä¿è‡´å¯†
                        // æ ¸å¿ƒï¼šåŠå¾„å›ºå®šï¼Œé«˜åº¦éšæœºï¼Œå½¢æˆåœ†æŸ±é¢
                        targetPositions[idx*3] = radius * Math.cos(theta);
                        targetPositions[idx*3+1] = bottomY + Math.random() * (topY - bottomY);
                        targetPositions[idx*3+2] = radius * Math.sin(theta);
                        idx++;
                    }
                });

                // --- 2. æ„å»ºå¥¶æ²¹è£±èŠ±è¾¹ç¼˜ (ä½¿ç”¨çƒä½“) ---
                // ç­–ç•¥ï¼šåœ¨æ¯ä¸€å±‚çš„é¡¶éƒ¨å’Œåº•éƒ¨è¾¹ç•Œæ”¾ç½®å¯†é›†çš„åœ†ç¯
                tiers.forEach(tier => {
                    const [radius, bottomY, topY] = tier;
                    const framingParticles = 180; // æ¯ä¸€åœˆçš„ç²’å­æ•°

                    // åº•éƒ¨èŠ±è¾¹
                    for(let i=0; i<framingParticles; i++) {
                        if(idx >= totalParticles) break;
                        const theta = (i / framingParticles) * Math.PI * 2;
                        targetPositions[idx*3] = (radius + 1) * Math.cos(theta); // åŠå¾„ç¨å¾®å¤§ä¸€ç‚¹çªå‡º
                        targetPositions[idx*3+1] = bottomY; // é«˜åº¦å›ºå®š
                        targetPositions[idx*3+2] = (radius + 1) * Math.sin(theta);
                        idx++;
                    }
                    // é¡¶éƒ¨èŠ±è¾¹
                    for(let i=0; i<framingParticles; i++) {
                        if(idx >= totalParticles) break;
                        const theta = (i / framingParticles) * Math.PI * 2;
                        targetPositions[idx*3] = (radius + 0.5) * Math.cos(theta);
                        targetPositions[idx*3+1] = topY; // é«˜åº¦å›ºå®š
                        targetPositions[idx*3+2] = (radius + 0.5) * Math.sin(theta);
                        idx++;
                    }
                });

                // --- 3. æ„å»ºé¡¶å±‚èœ¡çƒ›åŸºåº§ (ä½¿ç”¨å‰©ä½™ç²’å­) ---
                const candleCount = 6;
                const candleHeightParticles = 20;
                const topTierY = tiers[2][2]; // æœ€é¡¶å±‚é«˜åº¦

                for(let c=0; c<candleCount; c++) {
                    const candleAngle = (c / candleCount) * Math.PI * 2;
                    const candleX = 8 * Math.cos(candleAngle);
                    const candleZ = 8 * Math.sin(candleAngle);

                    for(let i=0; i<candleHeightParticles; i++) {
                        if(idx >= totalParticles) break;
                        // å‚ç›´å †å 
                        targetPositions[idx*3] = candleX + (Math.random()-0.5)*0.5; // ç¨å¾®æŠ–åŠ¨å¢åŠ è‡ªç„¶æ„Ÿ
                        targetPositions[idx*3+1] = topTierY + i * 0.4;
                        targetPositions[idx*3+2] = candleZ + (Math.random()-0.5)*0.5;
                        idx++;
                    }
                }

                // å‰©ä¸‹çš„ç²’å­éšä¾¿æ‰”åˆ°ä¸­é—´å¡«ç©º
                while(idx < totalParticles) {
                     targetPositions[idx*3] = (Math.random()-0.5)*10;
                     targetPositions[idx*3+1] = (Math.random()-0.5)*30;
                     targetPositions[idx*3+2] = (Math.random()-0.5)*10;
                     idx++;
                }
            }
            else if (type === 'avoid') { // é¿è®©æ¨¡å¼
                for(let i=0; i<totalParticles; i++){
                    const r=60+Math.random()*60; const ang=Math.random()*2*Math.PI;
                    let x=r*Math.cos(ang); let y=r*Math.sin(ang)*0.8; let z=(Math.random()-0.5)*80; 
                    // è…¾å‡ºä¸­é—´åŒºåŸŸ
                    if (Math.abs(x) < 35 && Math.abs(y) < 25) {
                         z = -80 - Math.random() * 50; // æ¨åˆ°åé¢å»
                         x *= 1.5; y *= 1.5; // æˆ–è€…æ¨åˆ°æ—è¾¹
                    }
                    targetPositions[i*3] = x; targetPositions[i*3+1] = y; targetPositions[i*3+2] = z;
                }
            }
        }
        calculateTargets('cake');
 
        document.getElementById('photo-input').addEventListener('change', (e) => {
            const f = e.target.files;
            if(f.length){
                photoImages = [];
                let loadCount = 0;
                const limit = Math.min(f.length, 30);
                for(let i=0; i<limit; i++){
                    const r = new FileReader();
                    r.onload = (ev) => {
                        const img = new Image(); img.src=ev.target.result;
                        img.onload=()=>{
                            const t=new THREE.CanvasTexture(img); t.colorSpace=THREE.SRGBColorSpace;
                            photoImages.push(t); loadCount++;
                            if(loadCount === limit) createGalleryCloud();
                        }
                    };
                    r.readAsDataURL(f[i]);
                }
            }
        });
 
        // --- 7. åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
 
            // æ‰‹åŠ¿æ—‹è½¬æ§åˆ¶
            let targetRotX = 0, targetRotY = 0;
            if (mode !== 'photo') {
                targetRotY = handRot.y * 0.3; 
                targetRotX = handRot.x * 0.5;
            }
            // å¢åŠ ä¸€ç‚¹åŸºç¡€è‡ªåŠ¨æ—‹è½¬
            targetRotX += time * 0.1;

            const rotLerp = 0.05;
            meshCubes.rotation.x = THREE.MathUtils.lerp(meshCubes.rotation.x, targetRotY, rotLerp);
            meshCubes.rotation.y = THREE.MathUtils.lerp(meshCubes.rotation.y, targetRotX, rotLerp);
            meshSpheres.rotation.copy(meshCubes.rotation); 
            meshFrames.rotation.copy(meshCubes.rotation);
            galleryGroup.rotation.copy(meshCubes.rotation); // ç…§ç‰‡å¢™ä¹Ÿè·Ÿç€è½¬
 
            // æ¨¡å¼ç‰¹å®šåŠ¨ç”»
            if (mode === 'cake') {
                flameGroup.visible = true;
                const flicker = 1 + Math.sin(time*15)*0.05 + Math.cos(time*20)*0.05; // çƒ›ç«é—ªçƒ
                topFlame.scale.set(flicker, flicker*1.1, flicker);
                glowMesh.scale.set(flicker, flicker, flicker);
                glowMesh.lookAt(camera.position); // å…‰æ™•å§‹ç»ˆæœå‘ç›¸æœº
                
                // å°†çƒ›ç«æ”¾ç½®åœ¨è›‹ç³•é¡¶éƒ¨ä¸­å¿ƒï¼Œå¹¶è·Ÿéšæ—‹è½¬
                flameGroup.position.set(0, 22, 0); 
                flameGroup.position.applyEuler(meshCubes.rotation);
            } else {
                flameGroup.visible = false;
            }
 
            // ç…§ç‰‡å’Œæ–‡å­—åŠ¨ç”» (æ·¡å…¥æ·¡å‡ºå’Œç¼©æ”¾)
            animState.photo = THREE.MathUtils.lerp(animState.photo, (mode==='photo'?1:0), 0.1);
            photoGroup.visible = animState.photo > 0.01;
            photoGroup.scale.setScalar(0.8 + animState.photo*0.2); photoGroup.position.z = (1-animState.photo)*-50; photoGroup.material.opacity = animState.photo;

            animState.text = THREE.MathUtils.lerp(animState.text, (mode==='text'?1:0), 0.1);
            textPlane.visible = animState.text > 0.01;
            textPlane.material.opacity = animState.text;
            textPlane.scale.setScalar(0.9 + Math.sin(time*2)*0.05); textPlane.position.y = Math.sin(time)*2;
 
            // æ˜Ÿç³»ç…§ç‰‡åŠ¨ç”»
            animState.galaxy = THREE.MathUtils.lerp(animState.galaxy, (mode==='nebula'?1:0), 0.08);
            galleryGroup.children.forEach(mesh => {
                if(mode==='nebula') {
                    mesh.position.lerp(mesh.userData.targetPos, 0.08);
                    mesh.lookAt(camera.position);
                } else {
                    mesh.position.lerp(new THREE.Vector3(0,0,0), 0.1);
                }
                mesh.scale.setScalar(animState.galaxy * (1 + Math.sin(time+mesh.id)*0.1));
            });
 
            // ç²’å­ä½ç½®æ›´æ–° (æ ¸å¿ƒæ’å€¼)
            const particleLerp = (mode === 'photo' || mode === 'text') ? 0.15 : 0.06; // é¿è®©æ¨¡å¼å¿«ä¸€ç‚¹ï¼Œè›‹ç³•æ¨¡å¼æ…¢ä¸€ç‚¹
            
            let sphereIdx = 0; // ç”¨äºè¿½è¸ªå“ªäº›æ˜¯çƒä½“ç²’å­
            for(let i=0; i<totalParticles; i++){
                const ix=i*3, iy=i*3+1, iz=i*3+2;
                currentPositions[ix] += (targetPositions[ix]-currentPositions[ix])*particleLerp;
                currentPositions[iy] += (targetPositions[iy]-currentPositions[iy])*particleLerp;
                currentPositions[iz] += (targetPositions[iz]-currentPositions[iz])*particleLerp;
                
                dummy.position.set(currentPositions[ix], currentPositions[iy], currentPositions[iz]);
                
                // ç²’å­è‡ªè½¬å’Œç¼©æ”¾
                let s = 1.0;
                if (mode === 'cake') {
                   // åœ¨è›‹ç³•æ¨¡å¼ä¸‹ï¼Œè®©ç²’å­è½»å¾®æµ®åŠ¨ï¼Œçœ‹èµ·æ¥æ›´æœ‰é­”åŠ›
                   dummy.position.y += Math.sin(time*2 + i*0.1)*0.2;
                   
                   // å¦‚æœæ˜¯çƒä½“ï¼ˆå¥¶æ²¹ï¼‰ï¼Œè®©å®ƒå°ä¸€ç‚¹ï¼›å¦‚æœæ˜¯ç«‹æ–¹ä½“ï¼ˆè›‹ç³•ä½“ï¼‰ï¼Œå¤§ä¸€ç‚¹
                   if(i >= countCubes && i < countCubes + countSpheres) s = 0.7; 
                   else s = 1.0;

                   dummy.rotation.set(time*0.5+i, time*0.3+i, 0);
                } else if (mode === 'photo' || mode === 'text') {
                   dummy.rotation.set(0,0,0); // é¿è®©æ¨¡å¼ä¸‹é™æ­¢
                   s = 0.5; // å˜å°ä¸æŠ¢é•œ
                } else {
                   dummy.rotation.set(time+i, i, 0); // çˆ†å‘æ¨¡å¼ä¹±è½¬
                }
                
                dummy.scale.set(s,s,s);
                dummy.updateMatrix();
 
                if(i<countCubes) meshCubes.setMatrixAt(i, dummy.matrix);
                else if(i<countCubes+countSpheres) { meshSpheres.setMatrixAt(i-countCubes, dummy.matrix); sphereIdx++; }
                else meshFrames.setMatrixAt(i-countCubes-countSpheres, dummy.matrix);
            }
            meshCubes.instanceMatrix.needsUpdate=true;
            meshSpheres.instanceMatrix.needsUpdate=true;
            meshFrames.instanceMatrix.needsUpdate=true;
 
            // å½©çº¸é£˜è½
            const cp = confettiSystem.geometry.attributes.position.array;
            for(let i=0; i<confettiCount; i++){
                cp[i*3+1] -= 0.3; cp[i*3] += Math.sin(time*0.5 + i)*0.2; 
                if(cp[i*3+1]<-120) cp[i*3+1]=120;
            }
            confettiSystem.geometry.attributes.position.needsUpdate=true;
            confettiSystem.rotation.y += 0.005;
 
            renderer.render(scene, camera);
        }
        animate();
 
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
 
        // --- 8. æ‰‹åŠ¿è¯†åˆ« ---
        const videoElement = document.getElementById('input_video');
        const statusText = document.getElementById('status-text');
 
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            statusText.style.display = 'block';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const cx = (lm[0].x+lm[9].x)/2; const cy = (lm[0].y+lm[9].y)/2;
                // åè½¬Xè½´ä»¥åŒ¹é…é•œåƒè§†é¢‘
                handRot.x = -(cx-0.5)*4; handRot.y = (cy-0.5)*3;
                handleGesture(detect(lm));
            }
        }
        function detect(lm) {
            const d = (i1, i2) => Math.hypot(lm[i1].x-lm[i2].x, lm[i1].y-lm[i2].y);
            const fingerIsUp = (tip, pip) => d(tip, 0) > d(pip, 0) * 1.1; // å¢åŠ ä¸€ç‚¹é˜ˆå€¼
            const i=fingerIsUp(8,6), m=fingerIsUp(12,10), r=fingerIsUp(16,14), p=fingerIsUp(20,18);
            
            if(!i&&!m&&!r&&!p) return 'FIST'; 
            if(i && !m && !r && !p) return 'POINTING'; 
            if(d(4,8)<0.06 && m && r && p && d(8,12)>0.1) return 'OK'; // OKæ‰‹åŠ¿éœ€è¦æ‹‡æŒ‡é£ŸæŒ‡æ¥è§¦ï¼Œå…¶ä»–æŒ‡å¤´ä¼¸ç›´
            if(i&&m&&r&&p && d(4,8)>0.1) return 'OPEN';
            return 'idle';
        }
        let lastG = ''; let gestureDebounce = 0;
        function handleGesture(g) {
            if(g === 'idle' || g === lastG) return;
            // ç®€å•çš„é˜²æŠ–
            if(Date.now() - gestureDebounce < 300) return;
            gestureDebounce = Date.now();

            lastG = g; statusText.innerText = g;
            switch(g){
                case 'OPEN': 
                    mode='nebula'; calculateTargets('nebula'); 
                    if(galleryGroup.children.length === 0 && photoImages.length > 0) createGalleryCloud();
                    break;
                case 'FIST': mode='cake'; calculateTargets('cake'); break;
                case 'POINTING': 
                    mode='photo'; calculateTargets('avoid'); 
                    if(photoImages.length) {
                        photoPlane.material.map=photoImages[Math.floor(Math.random()*photoImages.length)];
                        photoPlane.material.needsUpdate=true;
                    } else {
                        const c=document.createElement('canvas');c.width=500;c.height=400;
                        const x=c.getContext('2d');x.fillStyle='rgba(255,105,180,0.8)';x.fillRect(0,0,500,400);
                        x.strokeStyle='#fff';x.lineWidth=10;x.strokeRect(20,20,460,360);
                        x.fillStyle='#fff';x.font='bold 40px Arial';x.textAlign='center';x.textBaseline='middle';
                        x.fillText("è¯·å…ˆä¸Šä¼ ç…§ç‰‡",250,180);x.font='30px Arial';x.fillText("Please Upload Photos",250,230);
                        photoPlane.material.map=new THREE.CanvasTexture(c); photoPlane.material.needsUpdate=true;
                    }
                    break;
                case 'OK': mode='text'; calculateTargets('avoid'); break;
            }
        }
 
        const hands = new Hands({locateFile: f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.6});
        hands.onResults(onResults);
        const cam = new Camera(videoElement, {onFrame: async()=>{await hands.send({image:videoElement})}, width:480, height:360});
        cam.start();
    </script>
</body>
</html>
