<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Birthday Cake Photo Display</title>
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: radial-gradient(circle at center, #0a001f 0%, #000000 100%);
            font-family: 'Arial', sans-serif; 
        }
         
        #top-header {
            position: absolute; top: 15px; left: 0; width: 100%;
            text-align: center; z-index: 50; pointer-events: none;
        }
        #top-header h1 {
            font-family: 'Brush Script MT', cursive; font-size: 55px; margin: 0;
            background: linear-gradient(to bottom, #fff, #ff69b4);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(255, 105, 180, 0.6));
            animation: floatText 4s ease-in-out infinite;
        }
        @keyframes floatText { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-8px);} }

        #ui-container {
            position: absolute; top: 120px; left: 20px; width: 260px;
            padding: 20px; 
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff; z-index: 100; display: flex; flex-direction: column; gap: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }

        #video-wrapper {
            width: 100%; height: 160px; border-radius: 10px; overflow: hidden;
            background: #000; position: relative; transform: scaleX(-1);
            border: 1px solid rgba(255, 105, 180, 0.3);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
         
        .status-badge {
            position: absolute; top: 8px; right: 8px;
            background: #ff69b4; color: #000;
            padding: 3px 8px; border-radius: 4px; font-size: 11px;
            transform: scaleX(-1); font-weight: 800; display: none;
        }

        .file-upload {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255,105,180,0.3);
            padding: 10px; border-radius: 8px; color: #ff69b4; cursor: pointer;
            text-align: center; font-size: 13px; transition: 0.3s; font-weight: bold;
        }
        .file-upload:hover { background: rgba(255, 105, 180, 0.2); }
        input[type="file"] { display: none; }

        #gesture-info {
            font-size: 11px; color: #bbb; line-height: 1.6;
            background: rgba(0,0,0,0.4); padding: 12px; border-radius: 8px;
        }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            color: #ff69b4; z-index: 999; flex-direction: column;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="top-header"><h1>Happy Birthday</h1></div>

    <div id="loader">
        <h2>üéÇ ÁîªÈù¢Èò≤ÊäñÁ≥ªÁªüÂêØÂä®...</h2>
        <p>ÂàùÂßãÂåñ‰∏≠</p>
    </div>

    <div id="ui-container">
        <div id="video-wrapper">
            <video id="input_video"></video>
            <div id="status-text" class="status-badge">Ready</div>
        </div>
        <label class="file-upload" for="photo-input">üì∑ ÂØºÂÖ•Â§öÂº†ÁÖßÁâá (Âª∫ËÆÆ10+)</label>
        <input type="file" id="photo-input" accept="image/*" multiple>
        <div id="gesture-info">
            ‚úã <b>Âº†ÂºÄ</b>ÔºöÁÖßÁâáÊòüÁ≥ªÁàÜÂèë<br>
            ‚úä <b>Êè°Êã≥</b>ÔºöÁîüÊó•ËõãÁ≥ï<br>
            ‚òùÔ∏è <b>ÂçïÊåá</b>ÔºöÂçïÂº†ÁâπÂÜô (ÁªùÂØπÈùôÊ≠¢)<br>
            üëå <b>OKÊâã</b>ÔºöÂ∑®ÂûãËâ∫ÊúØÂ≠ó
        </div>
    </div>

    <script>
        // --- 1. Âú∫ÊôØ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a001f, 0.0015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 85;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // ÁÅØÂÖâ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const mainLight = new THREE.PointLight(0xff69b4, 3, 150);
        mainLight.position.set(30, 40, 50);
        scene.add(mainLight);
        const candleLight = new THREE.PointLight(0xffaa00, 2, 60);
        candleLight.position.set(0, 35, 0);
        scene.add(candleLight);

        // --- 2. Èõ™Ëä±ÔºàÊîπ‰∏∫ÂΩ©Â±ëÁ≤íÂ≠êÔºâ---
        function createConfettiTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = ['#ff69b4','#ffff00','#00ffff','#ff00ff'][Math.floor(Math.random()*4)];
            ctx.fillRect(10,10,44,44);
            return new THREE.CanvasTexture(canvas);
        }
        const confettiCount = 800;
        const confettiGeo = new THREE.BufferGeometry();
        const confettiPos = new Float32Array(confettiCount * 3);
        for(let i=0;i<confettiCount*3;i++) confettiPos[i] = (Math.random()-0.5)*250;
        confettiGeo.setAttribute('position', new THREE.BufferAttribute(confettiPos, 3));
        const confettiMat = new THREE.PointsMaterial({
            size: 4.5, transparent: true, opacity: 0.9,
            map: createConfettiTexture(), blending: THREE.AdditiveBlending, depthWrite: false
        });
        const confettiSystem = new THREE.Points(confettiGeo, confettiMat);
        scene.add(confettiSystem);

        // --- 3. Á≤íÂ≠êÁ≥ªÁªüÔºàËõãÁ≥ïË£ÖÈ•∞Ôºâ---
        const totalParticles = 2400;
        const countCubes = 1100; const countSpheres = 600; const countFrames = 300; const countGifts = 400;

        const cubeGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const sphereGeo = new THREE.SphereGeometry(0.6, 16, 16);
        const frameGeo = new THREE.TorusGeometry(1.4, 0.25, 4, 4); frameGeo.rotateZ(Math.PI/4);
        const giftGeo = new THREE.BoxGeometry(1.0, 1.0, 1.0);

        const matCream = new THREE.MeshStandardMaterial({ color: 0xfff8e1, emissive: 0xaa8800, roughness: 0.3 });
        const matColor = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
        const matFrame = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x666666, metalness: 0.9 });
         
        const gCan = document.createElement('canvas'); gCan.width=64; gCan.height=64;
        const gCtx = gCan.getContext('2d');
        gCtx.fillStyle='#ff69b4'; gCtx.fillRect(0,0,64,64);
        gCtx.fillStyle='#ffd700'; gCtx.fillRect(28,0,8,64); gCtx.fillRect(0,28,64,8);
        const matGift = new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(gCan) });

        const meshCubes = new THREE.InstancedMesh(cubeGeo, matCream, countCubes);
        const meshSpheres = new THREE.InstancedMesh(sphereGeo, matColor, countSpheres);
        const meshFrames = new THREE.InstancedMesh(frameGeo, matFrame, countFrames);
        const meshGifts = new THREE.InstancedMesh(giftGeo, matGift, countGifts);

        scene.add(meshCubes); scene.add(meshSpheres); scene.add(meshFrames); scene.add(meshGifts);

        const targetPositions = new Float32Array(totalParticles * 3);
        const currentPositions = new Float32Array(totalParticles * 3);
        const dummy = new THREE.Object3D();
        const colorPink = new THREE.Color(0xff69b4);
        const colorYellow = new THREE.Color(0xffff00);
        let sIdx = 0;

        for(let i=0; i<totalParticles; i++) {
            currentPositions[i*3] = (Math.random()-0.5)*150;
            currentPositions[i*3+1] = (Math.random()-0.5)*150;
            currentPositions[i*3+2] = (Math.random()-0.5)*150;
            if(i>=countCubes && i<countCubes+countSpheres) meshSpheres.setColorAt(sIdx++, Math.random()>0.5?colorPink:colorYellow);
        }

        // --- 4. Ëú°ÁÉõ + ÁÅ´ÁÑ∞ ---
        const candleGeo = new THREE.CylinderGeometry(0.8, 0.8, 12, 16);
        const candleMat = new THREE.MeshStandardMaterial({color: 0xffffff});
        const candle = new THREE.Mesh(candleGeo, candleMat);
        candle.position.y = 28;
        scene.add(candle);

        const flameGeo = new THREE.SphereGeometry(1.2, 16, 16);
        const flameMat = new THREE.MeshBasicMaterial({color: 0xffaa00, transparent:true, opacity:0.8});
        const flame = new THREE.Mesh(flameGeo, flameMat);
        flame.position.y = 35;
        scene.add(flame);

        // ÂΩ©Â∏¶ÂÖâÂ∏¶
        class Ribbon extends THREE.Curve {
            getPoint(t) {
                const turns = 5; const angle = t*Math.PI*2*turns;
                const h = (t-0.5)*60; 
                const r = 18 + Math.sin(t*Math.PI*6)*4; 
                return new THREE.Vector3(Math.cos(angle)*r, h, Math.sin(angle)*r);
            }
        }
        const ribbonMesh = new THREE.Mesh(new THREE.TubeGeometry(new Ribbon(), 140, 0.5, 8, false), 
            new THREE.MeshBasicMaterial({color:0xff69b4, transparent:true, opacity:0.7, blending:THREE.AdditiveBlending}));
        ribbonMesh.visible = false;
        scene.add(ribbonMesh);

        // --- 5. Â∑®ÂûãËâ∫ÊúØÂ≠ó ---
        const textPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(50, 15), 
            new THREE.MeshBasicMaterial({side:THREE.DoubleSide, transparent:true})
        );
        textPlane.renderOrder = 999; 
         
        function makeArtTextTex() {
            const c=document.createElement('canvas'); c.width=4096; c.height=1024;
            const x=c.getContext('2d');
            x.shadowColor="#ff69b4"; x.shadowBlur=50;
            x.fillStyle="#fff"; 
            x.font="bold 380px 'Brush Script MT', cursive"; 
            x.textAlign="center"; x.textBaseline="middle";
            x.fillText("Happy Birthday", 2048, 512);
            return new THREE.CanvasTexture(c);
        }
        textPlane.material.map = makeArtTextTex();
        textPlane.visible = false;
        scene.add(textPlane);

        // --- 6. ÁÖßÁâáÁõ∏ÂÖ≥ ---
        const photoGroup = new THREE.Group();
        const photoPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1),new THREE.MeshBasicMaterial({ side: THREE.DoubleSide }));
        const photoBorder = new THREE.Mesh(new THREE.PlaneGeometry(37, 28), new THREE.MeshBasicMaterial({color:0xff69b4}));
        photoBorder.position.z = -0.1;
        photoGroup.add(photoPlane); photoGroup.add(photoBorder);
        photoGroup.visible = false;
        photoGroup.renderOrder = 999; 
        scene.add(photoGroup);

        const galleryGroup = new THREE.Group();
        scene.add(galleryGroup);

        let mode = 'cake';
        let photoImages = [];
        let handRot = {x:0, y:0};
        let animState = { photo: 0, text: 0, galaxy: 0 };

        function createGalleryCloud() {
            while(galleryGroup.children.length > 0){ galleryGroup.remove(galleryGroup.children[0]); }
            if(photoImages.length === 0) return;

            const totalGalleryCount = 40;
            const geo = new THREE.PlaneGeometry(8, 6);
            const borderGeo = new THREE.PlaneGeometry(8.5, 6.5);
            const borderMat = new THREE.MeshBasicMaterial({color: 0xff69b4});

            for(let i=0; i<totalGalleryCount; i++) {
                const imgTex = photoImages[i % photoImages.length];
                const mat = new THREE.MeshBasicMaterial({map: imgTex, side: THREE.DoubleSide});
                 
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.05;
                mesh.add(border);

                const r = 25 + Math.random() * 35;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                 
                const tx = r * Math.sin(phi) * Math.cos(theta);
                const ty = r * Math.sin(phi) * Math.sin(theta);
                const tz = r * Math.cos(phi);

                mesh.userData = {
                    targetPos: new THREE.Vector3(tx, ty, tz),
                    startPos: new THREE.Vector3(0, 0, 0),
                    rotSpeed: (Math.random()-0.5) * 0.02
                };
                 
                mesh.position.set(0,0,0);
                mesh.scale.set(0,0,0);
                 
                galleryGroup.add(mesh);
            }
        }

        function calculateTargets(type) {
            const scale = 1.0;
            const textW = 50; const textH = 18;
            const photoW = 55; const photoH = 45; 

            if (type === 'nebula') {
                for(let i=0; i<totalParticles; i++){
                    const r=80*Math.cbrt(Math.random()); const th=Math.random()*2*Math.PI; const ph=Math.acos(2*Math.random()-1);
                    targetPositions[i*3] = r*Math.sin(ph)*Math.cos(th);
                    targetPositions[i*3+1] = r*Math.sin(ph)*Math.sin(th);
                    targetPositions[i*3+2] = r*Math.cos(ph);
                }
            }
            else if (type === 'cake') {
                // Â§öÂ±ÇËõãÁ≥ïÂΩ¢Áä∂Ôºö3Â±ÇÔºå‰ªé‰∏ãÂà∞‰∏äÈÄêÊ∏êÂèòÂ∞è
                for(let i=0; i<totalParticles; i++){
                    const layer = Math.floor(Math.random() * 3); // 0=Â∫ï,1=‰∏≠,2=È°∂
                    const layerHeight = [-15, 0, 15][layer];
                    const maxRadius = [22, 16, 10][layer];
                    const hOffset = layerHeight + (Math.random()-0.5)*8;

                    const r = maxRadius * Math.sqrt(Math.random());
                    const th = Math.random()*2*Math.PI;
                    targetPositions[i*3] = r*Math.cos(th);
                    targetPositions[i*3+1] = hOffset;
                    targetPositions[i*3+2] = r*Math.sin(th);
                }
            }
            else if (type === 'avoid') {
                const w = (mode==='photo') ? photoW : textW;
                const h = (mode==='photo') ? photoH : textH;
                 
                for(let i=0; i<totalParticles; i++){
                    const r=50+Math.random()*40; const ang=Math.random()*2*Math.PI;
                    let x=r*Math.cos(ang); let y=r*Math.sin(ang)*0.6; 
                    let z=(Math.random()-0.5)*50; 
                     
                    if (Math.abs(x) < w/2 && Math.abs(y) < h/2) {
                        z = -60 - Math.random() * 40; 
                    }
                    targetPositions[i*3] = x;
                    targetPositions[i*3+1] = y;
                    targetPositions[i*3+2] = z;
                }
            }
        }
        calculateTargets('cake');

        document.getElementById('photo-input').addEventListener('change', (e) => {
            const f = e.target.files;
            if(f.length){
                photoImages = [];
                let loadCount = 0;
                const limit = Math.min(f.length, 30);
                 
                for(let i=0; i<limit; i++){
                    const r = new FileReader();
                    r.onload = (ev) => {
                        const img = new Image(); img.src=ev.target.result;
                        img.onload=()=>{
                            const t=new THREE.CanvasTexture(img); t.colorSpace=THREE.SRGBColorSpace;
                            photoImages.push(t);
                            loadCount++;
                            if(loadCount === limit) {
                                createGalleryCloud();
                            }
                        }
                    };
                    r.readAsDataURL(f[i]);
                }
            }
        });

        // --- 7. Âä®Áîª ---
        const clock = new THREE.Clock();
        const dummyV = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            let tx = 0, ty = 0;
            if (mode !== 'photo') {
                tx = handRot.y * 0.5;
                ty = handRot.x * 0.5;
            }

            const rotSpeed = 0.08;
            meshCubes.rotation.x = THREE.MathUtils.lerp(meshCubes.rotation.x, tx, rotSpeed);
            meshCubes.rotation.y = THREE.MathUtils.lerp(meshCubes.rotation.y, ty, rotSpeed);
            meshSpheres.rotation.copy(meshCubes.rotation); meshFrames.rotation.copy(meshCubes.rotation); meshGifts.rotation.copy(meshCubes.rotation);

            galleryGroup.rotation.y += 0.002;
            galleryGroup.rotation.x = meshCubes.rotation.x * 0.5;
            galleryGroup.rotation.y += meshCubes.rotation.y * 0.5;

            // ËõãÁ≥ïÊ®°Âºè
            if (mode === 'cake') {
                candle.visible = true;
                flame.visible = true;
                flame.scale.set(1 + Math.sin(time*8)*0.2, 1.4 + Math.sin(time*7)*0.3, 1 + Math.sin(time*9)*0.2);
                candleLight.intensity = 2 + Math.sin(time*6)*0.5;
                ribbonMesh.visible = true;
                ribbonMesh.rotation.copy(meshCubes.rotation);
                ribbonMesh.rotation.y += time * 0.5;
            } else {
                candle.visible = false;
                flame.visible = false;
                ribbonMesh.visible = false;
            }

            // ÂçïÂº†ÁâπÂÜô
            if (mode === 'photo') {
                photoGroup.visible = true;
                animState.photo = THREE.MathUtils.lerp(animState.photo, 1, 0.15); 
                const s = animState.photo;
                const z = -20 * (1-s) + 12; 
                photoGroup.scale.set(s, s, s);
                photoGroup.position.set(0, 0, z); 
                photoGroup.rotation.z = (1-s) * 0.3;
            } else {
                photoGroup.visible = false;
                animState.photo = 0;
            }

            // ÊñáÂ≠óÊ®°Âºè
            if (mode === 'text') {
                textPlane.visible = true;
                animState.text = THREE.MathUtils.lerp(animState.text, 1, 0.1);
                const s = 1 + Math.sin((1-animState.text)*Math.PI)*0.3; 
                textPlane.scale.set(s,s,1);
                textPlane.position.set(0, Math.sin(time*2)*0.5, 15); 
            } else {
                textPlane.visible = false;
                animState.text = 0;
            }

            // ÁÖßÁâáÊòüÁ≥ªÊ®°Âºè
            if (mode === 'nebula') {
                animState.galaxy = THREE.MathUtils.lerp(animState.galaxy, 1, 0.05);
                galleryGroup.children.forEach(mesh => {
                    mesh.position.lerp(mesh.userData.targetPos, 0.05);
                    mesh.scale.setScalar(animState.galaxy);
                    mesh.lookAt(camera.position);
                    mesh.position.y += Math.sin(time + mesh.id) * 0.02;
                });
            } else {
                animState.galaxy = THREE.MathUtils.lerp(animState.galaxy, 0, 0.1);
                galleryGroup.children.forEach(mesh => {
                    mesh.position.lerp(new THREE.Vector3(0,0,0), 0.1);
                    mesh.scale.setScalar(animState.galaxy);
                });
            }

            // Á≤íÂ≠êÊõ¥Êñ∞
            let ic=0, is=0, ifr=0, ig=0;
            const particleLerp = (mode === 'photo') ? 0.9 : 0.08;

            for(let i=0; i<totalParticles; i++){
                const ix=i*3, iy=i*3+1, iz=i*3+2;
                currentPositions[ix] += (targetPositions[ix]-currentPositions[ix])*particleLerp;
                currentPositions[iy] += (targetPositions[iy]-currentPositions[iy])*particleLerp;
                currentPositions[iz] += (targetPositions[iz]-currentPositions[iz])*particleLerp;
                 
                dummyV.set(currentPositions[ix], currentPositions[iy], currentPositions[iz]);
                dummy.position.copy(dummyV);
                 
                let s = 1.0;
                if (mode !== 'photo') {
                    if(i >= countCubes+countSpheres) { 
                        dummy.rotation.set(time+i, time*0.5+i, 0);
                        s = 1.0 + Math.sin(time*3+i)*0.15;
                    } else {
                        dummy.rotation.set(0,0,0);
                    }
                } else {
                    dummy.rotation.set(0,0,0);
                    s = 1.0;
                }
                 
                dummy.scale.set(s,s,s);
                dummy.updateMatrix();

                if(i<countCubes) meshCubes.setMatrixAt(ic++, dummy.matrix);
                else if(i<countCubes+countSpheres) meshSpheres.setMatrixAt(is++, dummy.matrix);
                else if(i<countCubes+countSpheres+countFrames) meshFrames.setMatrixAt(ifr++, dummy.matrix);
                else meshGifts.setMatrixAt(ig++, dummy.matrix);
            }
            meshCubes.instanceMatrix.needsUpdate=true;
            meshSpheres.instanceMatrix.needsUpdate=true;
            meshFrames.instanceMatrix.needsUpdate=true;
            meshGifts.instanceMatrix.needsUpdate=true;

            // ÂΩ©Â±ë‰∏ãËêΩ
            const cp = confettiSystem.geometry.attributes.position.array;
            for(let i=0; i<confettiCount; i++){
                cp[i*3+1] -= 0.35; 
                if(cp[i*3+1]<-100) cp[i*3+1]=100;
            }
            confettiSystem.geometry.attributes.position.needsUpdate=true;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 8. ÊâãÂäøËØÜÂà´ ---
        const videoElement = document.getElementById('input_video');
        const statusText = document.getElementById('status-text');

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            statusText.style.display = 'block';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const cx = (lm[0].x+lm[9].x)/2; const cy = (lm[0].y+lm[9].y)/2;
                handRot.x = (cx-0.5)*3; handRot.y = (cy-0.5)*3;
                handleGesture(detect(lm));
            }
        }
        function detect(lm) {
            const d = (i1, i2) => Math.hypot(lm[i1].x-lm[i2].x, lm[i1].y-lm[i2].y);
            const o = (t, p) => d(t, 0) > d(p, 0);
            const i=o(8,6), m=o(12,10), r=o(16,14), p=o(20,18);
            if(!i&&!m&&!r&&!p) return 'FIST';
            if(i && !m && !r && !p) return 'POINTING';
            if(d(4,8)<0.05&&m&&r&&p) return 'OK';
            if(i&&m&&r&&p) return 'OPEN';
            return 'UNKNOWN';
        }
        let lastG = '';
        function handleGesture(g) {
            if(g===lastG) return;
             
            lastG = g; statusText.innerText = g;
            switch(g){
                case 'OPEN': 
                    mode='nebula'; 
                    calculateTargets('nebula'); 
                    if(galleryGroup.children.length === 0 && photoImages.length > 0) createGalleryCloud();
                    break;
                case 'FIST': mode='cake'; calculateTargets('cake'); break;
                case 'POINTING': 
                    mode='photo'; 
                    if(photoImages.length) {
                        const tex = photoImages[Math.floor(Math.random()*photoImages.length)];
                        const img = tex.image;
                        const aspect = img.width / img.height;
                        const baseHeight = 27;
                        const w = baseHeight * aspect;
                        const h = baseHeight;
                        photoPlane.geometry.dispose();
                        photoPlane.geometry = new THREE.PlaneGeometry(w, h);
                        photoPlane.material.map = tex;
                        photoPlane.material.needsUpdate = true;
                    } else {
                        const c=document.createElement('canvas');c.width=400;c.height=300;
                        const x=c.getContext('2d');x.fillStyle='#000';x.fillRect(0,0,400,300);
                        x.fillStyle='#fff';x.font='30px Arial';x.textAlign='center';x.fillText("Please Upload Photos",200,150);
                        photoPlane.material.map=new THREE.CanvasTexture(c);
                    }
                    calculateTargets('avoid'); 
                    for(let i=0; i<totalParticles*3; i++) currentPositions[i] = targetPositions[i];
                    break;
                case 'OK': mode='text'; calculateTargets('avoid'); break;
            }
        }

        const hands = new Hands({locateFile: f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
        hands.onResults(onResults);
        const cam = new Camera(videoElement, {onFrame: async()=>{await hands.send({image:videoElement})}, width:320, height:240});
        cam.start();
    </script>
</body>
</html>
